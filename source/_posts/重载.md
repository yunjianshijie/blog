---
title: 重载&继承
abbrlink: 223
index_img: https://img2.imgtp.com/2024/04/13/uongvtVT.png ## /img/水神3.jpg
banner_img: /img/水神1.jpg
date: 2024-04-13
tags: cpp
---
#  重载
## 加号重载

> 对于内置的数据类型，编译器知道怎么搞


~~~ cpp
#include <iostream>
#include <string>
using namespace std;
class Person
{
public:
    int m_b;
    int m_a;
    Person operator+ (int n){
        Person teep;
        teep.m_a = this->m_a+n;
        teep.m_b = this->m_b+n;
        return teep;
    } // 通过成员函数重载 +
    //运算符重载也能重载函数重载
};
Person operator+ (Person &p1,Person &p2){
    Person teep;
    teep.m_a = p1.m_a+p2.m_a;
    teep.m_b =p1.m_b + p2.m_b;
    return teep;
    }
    
~~~


## 重载左移运算符

~~~ cpp
ostream &operator<<(ostream &out, Person &p)
{
    out << "m_a=" << p.m_a << " m_b=" << p.m_b << endl;
    return out;
}

~~~

## 递増运算符重载
一个前置运算符
~~~ cpp
   Person &operator++()
    {
        this->m_b++;
        this->m_a++;
        return *this;
    } // 前置++
    Person operator++(int)
    { // 返回值是不可以当作函数重载 ,所以int 为占位参数
        // 先理录当时结果
        Person tmep = *this;
        // 后 递増
        this->m_b++;
        this->m_a++;
        return tmep;
    }
~~~
## 仿函数

~~~ cpp
    class Person {
 void operator() (int a){
    cout << a;
 }
    }
    //调用两种方法
void test01(){
    Person b;
    b(1);
    //第二种用匿名对象
    Person()(2);
}
~~~

# 继承

## 语法

> 为了减小重复的代码

语法: class 子类 :继承方式 父类
~~~cpp
class A{
    public:
        int m_a;
        int m_b;
};
class B:public A
{
    int m_c;
};

~~~

## 继承方式

继承方式
1. 公共 
2. 保护
3. 私有
如下规则：
1. 父类中的保护权限儿子都拿不到
2. 共有的父类的成员权限不变
3. 保护-> 父有成员权限变为保护（私有同理）

##  继承中的对象模型
~~~ cpp
class A{
    public:
        int m_a;
        int m_b;
    protected:
        int m_d;
    private:
        int m_f;//父类属性能继承，但是编译器给隐藏了 -
};
class B:public A{
int m_c;
};
//一个B类对象大小为 20
~~~
## 继承中构造和析构的顺序

构造 先父再子
析构 先子后父


## 同名成员

父类同名加作用域

注意： 
1. 如果是同名函数，编译器会隐藏同名函数（包括重载） 
2. 同名成员 

## 多继承语法

class 子类： 继承方式 父类1,继承方式 父类2，继承方式 父类3
{

}


同名加作用域！！！

## 菱形继承

